# Intro to Solidity programming language

Solidity is an object-oriented, high-level language for implementing smart contracts that run on the [Ethereum Virtual Machine (EVM)](https://ethereum.org/en/developers/docs/evm/).
Smart contracts are programs that are executed inside a peer-to-peer network where nobody has special authority over the execution, and thus they allow to implement tokens of value, ownership, voting, and other kinds of logic.

## Anatomy of a Smart Contract
- SPDX License Identifier, comment indicating the smart contract license
- Pragmas, used to enable certain compiler features or checks, like allowing the compilation only with certain version of Solidity
- Imports, used to import code from another contract

## Structure of a Contract
Smart Contracts in Solidity are similar to classes in object-oriented programming languages: they can contain variables, functions, function modifier, struct types, and much more. 
Fore a more detailed description: https://docs.soliditylang.org/en/v0.8.12/structure-of-a-contract.html

## Smart Contract Data
Smart Contract have two main types of data location: 
- **Storage**, a persistent/permanent data stored on the blockchain in *state variables*. All the variables containing storage data should be declared so the contract can know how much storage it needs when compiling. The storage data types are similar to the one of other object oriented programming language with the addition of *address*, that holds an Ethereum address expressed with the exadecimal notation in 20 bytes.
- **Memory**, a temporary data that stores information only for the lifetime of a contract function's execution. The data its saved in *memory variables* that result more cheaper to use.
There are also two special global variable, used mainly to provide information about the blockchain or current transaction, the **Environment variables**:
- *block.timestamp*, a uint256 that holds the current block epoch timestamp;
- *msg.sender*, an address that holds the sender of the message or transaction.

**State Variables** determine the state of a smart contract, the basic data types supported are:
- Fixed length, like bool, int, bytes32, address;
- Variable length, like bytes or string;
- Complex types like array, mapping(key => value).
    - Arrays can be fixed-size or dynamically-sized. In terms of cost while pushing an element can be ok, removing an element can be costly;
    - Mappings are random access variable, originally inizialized with zeros. It's not possible to iterate over mappings unless there is a list of the significant keys.

## Smart Contract Functions
Functions can get information or set information in response to incoming transactions interacting with the contract state. Function can be labeled in:
- **view**, that only reads the state (similar to the const member functions in C++);
- **pure**, that doesn't read or write the state;
- functions that read and write the state. The state change they make should be put in a transaction to be written to the blockchain that costs a fee.

A particular function in smart contracts is the **constructor** that is executed when the contract is first deployed. Constructors are often used to initialize variables.
There are also some special built-in function like: `address.send()`, that allows a contract to send ETH to other accounts.

## Smart Contract Visibility
Functions and state variables can have different visibility:
- **Private**, that are exposed only to the contract they are defined in;
- **Public**, that are exposed both to internal function calls and to other contracts.

Other functions and state variables labels:
- **Internal**, that are exposed to child contracts and the contract itself;
- **External**, functions that are exposed only to other contracts.